<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ast (snow.Ast)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../index.html">Index</a> &#x00BB; <a href="../index.html">snow</a> &#x00BB; Ast</nav><header class="odoc-preamble"><h1>Module <code><span>Ast</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-typ"><a href="#type-typ" class="anchor"></a><code><span><span class="keyword">type</span> typ</span><span> = </span></code><ol><li id="type-typ.TI8" class="def variant constructor anchored"><a href="#type-typ.TI8" class="anchor"></a><code><span>| </span><span><span class="constructor">TI8</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>8-bit signed integer: range -128 to 127</p><span class="comment-delim">*)</span></div></li><li id="type-typ.TU8" class="def variant constructor anchored"><a href="#type-typ.TU8" class="anchor"></a><code><span>| </span><span><span class="constructor">TU8</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>8-bit unsigned integer: range 0 to 255</p><span class="comment-delim">*)</span></div></li><li id="type-typ.TI16" class="def variant constructor anchored"><a href="#type-typ.TI16" class="anchor"></a><code><span>| </span><span><span class="constructor">TI16</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>16-bit signed integer: range -32,768 to 32,767</p><span class="comment-delim">*)</span></div></li><li id="type-typ.TU16" class="def variant constructor anchored"><a href="#type-typ.TU16" class="anchor"></a><code><span>| </span><span><span class="constructor">TU16</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>16-bit unsigned integer: range 0 to 65,535</p><span class="comment-delim">*)</span></div></li><li id="type-typ.TI32" class="def variant constructor anchored"><a href="#type-typ.TI32" class="anchor"></a><code><span>| </span><span><span class="constructor">TI32</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>32-bit signed integer: range ±2.1 billion</p><span class="comment-delim">*)</span></div></li><li id="type-typ.TU32" class="def variant constructor anchored"><a href="#type-typ.TU32" class="anchor"></a><code><span>| </span><span><span class="constructor">TU32</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>32-bit unsigned integer: range 0 to 4.3 billion</p><span class="comment-delim">*)</span></div></li><li id="type-typ.TI64" class="def variant constructor anchored"><a href="#type-typ.TI64" class="anchor"></a><code><span>| </span><span><span class="constructor">TI64</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>64-bit signed integer: range ±9.2 × 10^18</p><span class="comment-delim">*)</span></div></li><li id="type-typ.TU64" class="def variant constructor anchored"><a href="#type-typ.TU64" class="anchor"></a><code><span>| </span><span><span class="constructor">TU64</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>64-bit unsigned integer: range 0 to 1.8 × 10^19</p><span class="comment-delim">*)</span></div></li><li id="type-typ.TInt" class="def variant constructor anchored"><a href="#type-typ.TInt" class="anchor"></a><code><span>| </span><span><span class="constructor">TInt</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Default signed integer (currently i64, may change)</p><span class="comment-delim">*)</span></div></li><li id="type-typ.TUint" class="def variant constructor anchored"><a href="#type-typ.TUint" class="anchor"></a><code><span>| </span><span><span class="constructor">TUint</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Default unsigned integer (currently u64, may change)</p><span class="comment-delim">*)</span></div></li><li id="type-typ.TF32" class="def variant constructor anchored"><a href="#type-typ.TF32" class="anchor"></a><code><span>| </span><span><span class="constructor">TF32</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>32-bit IEEE 754 floating point: ~7 decimal digits precision</p><span class="comment-delim">*)</span></div></li><li id="type-typ.TF64" class="def variant constructor anchored"><a href="#type-typ.TF64" class="anchor"></a><code><span>| </span><span><span class="constructor">TF64</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>64-bit IEEE 754 floating point: ~15-17 decimal digits precision</p><span class="comment-delim">*)</span></div></li><li id="type-typ.TFloat" class="def variant constructor anchored"><a href="#type-typ.TFloat" class="anchor"></a><code><span>| </span><span><span class="constructor">TFloat</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Default float type (currently f64 alias)</p><span class="comment-delim">*)</span></div></li><li id="type-typ.TBool" class="def variant constructor anchored"><a href="#type-typ.TBool" class="anchor"></a><code><span>| </span><span><span class="constructor">TBool</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Boolean type: true or false</p><span class="comment-delim">*)</span></div></li><li id="type-typ.TChar" class="def variant constructor anchored"><a href="#type-typ.TChar" class="anchor"></a><code><span>| </span><span><span class="constructor">TChar</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Unicode scalar value (UTF-32): represents a single character</p><span class="comment-delim">*)</span></div></li><li id="type-typ.TString" class="def variant constructor anchored"><a href="#type-typ.TString" class="anchor"></a><code><span>| </span><span><span class="constructor">TString</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>UTF-8 encoded immutable string</p><span class="comment-delim">*)</span></div></li><li id="type-typ.TBytes" class="def variant constructor anchored"><a href="#type-typ.TBytes" class="anchor"></a><code><span>| </span><span><span class="constructor">TBytes</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Binary blob: array of raw bytes for low-level operations</p><span class="comment-delim">*)</span></div></li><li id="type-typ.TUnit" class="def variant constructor anchored"><a href="#type-typ.TUnit" class="anchor"></a><code><span>| </span><span><span class="constructor">TUnit</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Unit type: represents void/empty value, written as ()</p><span class="comment-delim">*)</span></div></li><li id="type-typ.TArray" class="def variant constructor anchored"><a href="#type-typ.TArray" class="anchor"></a><code><span>| </span><span><span class="constructor">TArray</span> <span class="keyword">of</span> <a href="#type-typ">typ</a> * <span>int option</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Array types:</p><ul><li>TArray(T, Some n): Fixed-length array <code>T; n</code> allocated on stack</li><li>TArray(T, None): Variable-length slice <code>T</code> allocated on heap</li></ul><span class="comment-delim">*)</span></div></li><li id="type-typ.TTuple" class="def variant constructor anchored"><a href="#type-typ.TTuple" class="anchor"></a><code><span>| </span><span><span class="constructor">TTuple</span> <span class="keyword">of</span> <span><a href="#type-typ">typ</a> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Tuple type with heterogeneous elements: (T1, T2, ..., Tn) Used for multiple return values and structured data</p><span class="comment-delim">*)</span></div></li><li id="type-typ.TOption" class="def variant constructor anchored"><a href="#type-typ.TOption" class="anchor"></a><code><span>| </span><span><span class="constructor">TOption</span> <span class="keyword">of</span> <a href="#type-typ">typ</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Option&lt;T&gt; type: represents nullable values safely</p><ul><li>Some(value): contains a value of type T</li><li>None: represents absence of value</li></ul><span class="comment-delim">*)</span></div></li><li id="type-typ.TResult" class="def variant constructor anchored"><a href="#type-typ.TResult" class="anchor"></a><code><span>| </span><span><span class="constructor">TResult</span> <span class="keyword">of</span> <a href="#type-typ">typ</a> * <a href="#type-typ">typ</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Result&lt;T, E&gt; type: represents computations that may fail</p><ul><li>Ok(value): successful result with value of type T</li><li>Err(error): failure with error of type E</li></ul><span class="comment-delim">*)</span></div></li><li id="type-typ.TNever" class="def variant constructor anchored"><a href="#type-typ.TNever" class="anchor"></a><code><span>| </span><span><span class="constructor">TNever</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Never type (!): represents computations that never return normally Used for infinite loops, explicit panics, diverging functions</p><span class="comment-delim">*)</span></div></li><li id="type-typ.TFunc" class="def variant constructor anchored"><a href="#type-typ.TFunc" class="anchor"></a><code><span>| </span><span><span class="constructor">TFunc</span> <span class="keyword">of</span> <span><a href="#type-typ">typ</a> list</span> * <a href="#type-typ">typ</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Function type: (T1, T2, ..., Tn) -&gt; R First-class functions with argument types and return type</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Type system representation for SNOW language.</p><p>SNOW has a rich type system with explicit sizes for numeric types, algebraic data types, and function types. This type covers all possible types that can appear in SNOW programs.</p><p>Design notes:</p><ul><li>Explicit bit widths for integers prevent implicit conversions</li><li>TInt/TUint are aliases but distinct types for compatibility</li><li>TArray distinguishes fixed-size arrays from dynamic slices</li><li>TNever represents computations that never return (infinite loops, panics)</li></ul></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-unop"><a href="#type-unop" class="anchor"></a><code><span><span class="keyword">type</span> unop</span><span> = </span></code><ol><li id="type-unop.Not" class="def variant constructor anchored"><a href="#type-unop.Not" class="anchor"></a><code><span>| </span><span><span class="constructor">Not</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Logical negation (!): converts true to false and vice versa</p><span class="comment-delim">*)</span></div></li><li id="type-unop.Neg" class="def variant constructor anchored"><a href="#type-unop.Neg" class="anchor"></a><code><span>| </span><span><span class="constructor">Neg</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Arithmetic negation (-): numeric negation for numbers</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Unary operators in SNOW.</p><p>Currently only logical negation is supported. Future extensions may include arithmetic negation (-x), bitwise not (~x).</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-binop"><a href="#type-binop" class="anchor"></a><code><span><span class="keyword">type</span> binop</span><span> = </span></code><ol><li id="type-binop.Add" class="def variant constructor anchored"><a href="#type-binop.Add" class="anchor"></a><code><span>| </span><span><span class="constructor">Add</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Addition (+): numeric types and string concatenation</p><span class="comment-delim">*)</span></div></li><li id="type-binop.Sub" class="def variant constructor anchored"><a href="#type-binop.Sub" class="anchor"></a><code><span>| </span><span><span class="constructor">Sub</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Subtraction (-): numeric types only</p><span class="comment-delim">*)</span></div></li><li id="type-binop.Mul" class="def variant constructor anchored"><a href="#type-binop.Mul" class="anchor"></a><code><span>| </span><span><span class="constructor">Mul</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Multiplication ( * ): numeric types only</p><span class="comment-delim">*)</span></div></li><li id="type-binop.Div" class="def variant constructor anchored"><a href="#type-binop.Div" class="anchor"></a><code><span>| </span><span><span class="constructor">Div</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Division (/): numeric types, may raise division by zero</p><span class="comment-delim">*)</span></div></li><li id="type-binop.Mod" class="def variant constructor anchored"><a href="#type-binop.Mod" class="anchor"></a><code><span>| </span><span><span class="constructor">Mod</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Modulo (%): integer types only, may raise division by zero</p><span class="comment-delim">*)</span></div></li><li id="type-binop.Eq" class="def variant constructor anchored"><a href="#type-binop.Eq" class="anchor"></a><code><span>| </span><span><span class="constructor">Eq</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Equality (==): structural equality for all types</p><span class="comment-delim">*)</span></div></li><li id="type-binop.Neq" class="def variant constructor anchored"><a href="#type-binop.Neq" class="anchor"></a><code><span>| </span><span><span class="constructor">Neq</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Inequality (!=): negation of structural equality</p><span class="comment-delim">*)</span></div></li><li id="type-binop.Lt" class="def variant constructor anchored"><a href="#type-binop.Lt" class="anchor"></a><code><span>| </span><span><span class="constructor">Lt</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Less than (&lt;): ordered types (numbers, chars, strings)</p><span class="comment-delim">*)</span></div></li><li id="type-binop.Le" class="def variant constructor anchored"><a href="#type-binop.Le" class="anchor"></a><code><span>| </span><span><span class="constructor">Le</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Less or equal (&lt;=): ordered types</p><span class="comment-delim">*)</span></div></li><li id="type-binop.Gt" class="def variant constructor anchored"><a href="#type-binop.Gt" class="anchor"></a><code><span>| </span><span><span class="constructor">Gt</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Greater than (&gt;): ordered types</p><span class="comment-delim">*)</span></div></li><li id="type-binop.Ge" class="def variant constructor anchored"><a href="#type-binop.Ge" class="anchor"></a><code><span>| </span><span><span class="constructor">Ge</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Greater or equal (&gt;=): ordered types</p><span class="comment-delim">*)</span></div></li><li id="type-binop.And" class="def variant constructor anchored"><a href="#type-binop.And" class="anchor"></a><code><span>| </span><span><span class="constructor">And</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Logical AND (&amp;&amp;): boolean types, short-circuiting</p><span class="comment-delim">*)</span></div></li><li id="type-binop.Or" class="def variant constructor anchored"><a href="#type-binop.Or" class="anchor"></a><code><span>| </span><span><span class="constructor">Or</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Logical OR (||): boolean types, short-circuiting</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Binary operators in SNOW with their semantic meanings.</p><p>These operators follow common precedence rules:</p><ul><li>Arithmetic: *, /, % (highest) then +, -</li><li>Comparison: ==, !=, &lt;, &lt;=, &gt;, &gt;=</li><li>Logical: &amp;&amp; (higher) then || (lowest)</li></ul><p>Type checking ensures operands are compatible.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-expr"><a href="#type-expr" class="anchor"></a><code><span><span class="keyword">type</span> expr</span><span> = </span></code><ol><li id="type-expr.EI8" class="def variant constructor anchored"><a href="#type-expr.EI8" class="anchor"></a><code><span>| </span><span><span class="constructor">EI8</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>8-bit signed integer literal: 42i8</p><span class="comment-delim">*)</span></div></li><li id="type-expr.EU8" class="def variant constructor anchored"><a href="#type-expr.EU8" class="anchor"></a><code><span>| </span><span><span class="constructor">EU8</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>8-bit unsigned integer literal: 255u8</p><span class="comment-delim">*)</span></div></li><li id="type-expr.EI16" class="def variant constructor anchored"><a href="#type-expr.EI16" class="anchor"></a><code><span>| </span><span><span class="constructor">EI16</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>16-bit signed integer literal: 1000i16</p><span class="comment-delim">*)</span></div></li><li id="type-expr.EU16" class="def variant constructor anchored"><a href="#type-expr.EU16" class="anchor"></a><code><span>| </span><span><span class="constructor">EU16</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>16-bit unsigned integer literal: 65535u16</p><span class="comment-delim">*)</span></div></li><li id="type-expr.EI32" class="def variant constructor anchored"><a href="#type-expr.EI32" class="anchor"></a><code><span>| </span><span><span class="constructor">EI32</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>32-bit signed integer literal: 42i32</p><span class="comment-delim">*)</span></div></li><li id="type-expr.EU32" class="def variant constructor anchored"><a href="#type-expr.EU32" class="anchor"></a><code><span>| </span><span><span class="constructor">EU32</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>32-bit unsigned integer literal: 42u32</p><span class="comment-delim">*)</span></div></li><li id="type-expr.EI64" class="def variant constructor anchored"><a href="#type-expr.EI64" class="anchor"></a><code><span>| </span><span><span class="constructor">EI64</span> <span class="keyword">of</span> int64</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>64-bit signed integer literal: 42i64</p><span class="comment-delim">*)</span></div></li><li id="type-expr.EU64" class="def variant constructor anchored"><a href="#type-expr.EU64" class="anchor"></a><code><span>| </span><span><span class="constructor">EU64</span> <span class="keyword">of</span> int64</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>64-bit unsigned integer literal: 42u64</p><span class="comment-delim">*)</span></div></li><li id="type-expr.EInt" class="def variant constructor anchored"><a href="#type-expr.EInt" class="anchor"></a><code><span>| </span><span><span class="constructor">EInt</span> <span class="keyword">of</span> int64</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Default integer literal: 42 (inferred as int/i64)</p><span class="comment-delim">*)</span></div></li><li id="type-expr.EUint" class="def variant constructor anchored"><a href="#type-expr.EUint" class="anchor"></a><code><span>| </span><span><span class="constructor">EUint</span> <span class="keyword">of</span> int64</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Explicit unsigned integer literal: 42uint</p><span class="comment-delim">*)</span></div></li><li id="type-expr.EF32" class="def variant constructor anchored"><a href="#type-expr.EF32" class="anchor"></a><code><span>| </span><span><span class="constructor">EF32</span> <span class="keyword">of</span> float</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>32-bit float literal: 3.14f32</p><span class="comment-delim">*)</span></div></li><li id="type-expr.EF64" class="def variant constructor anchored"><a href="#type-expr.EF64" class="anchor"></a><code><span>| </span><span><span class="constructor">EF64</span> <span class="keyword">of</span> float</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>64-bit float literal: 3.14f64</p><span class="comment-delim">*)</span></div></li><li id="type-expr.EFloat" class="def variant constructor anchored"><a href="#type-expr.EFloat" class="anchor"></a><code><span>| </span><span><span class="constructor">EFloat</span> <span class="keyword">of</span> float</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Default float literal: 3.14 (inferred as float/f64)</p><span class="comment-delim">*)</span></div></li><li id="type-expr.EBool" class="def variant constructor anchored"><a href="#type-expr.EBool" class="anchor"></a><code><span>| </span><span><span class="constructor">EBool</span> <span class="keyword">of</span> bool</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Boolean literal: true or false</p><span class="comment-delim">*)</span></div></li><li id="type-expr.EChar" class="def variant constructor anchored"><a href="#type-expr.EChar" class="anchor"></a><code><span>| </span><span><span class="constructor">EChar</span> <span class="keyword">of</span> char</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Character literal: 'A', '\n', '\u</p><p>F4A9</p><p>'</p><span class="comment-delim">*)</span></div></li><li id="type-expr.EString" class="def variant constructor anchored"><a href="#type-expr.EString" class="anchor"></a><code><span>| </span><span><span class="constructor">EString</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>String literal: &quot;hello&quot;, &quot;world\n&quot;</p><span class="comment-delim">*)</span></div></li><li id="type-expr.EBytes" class="def variant constructor anchored"><a href="#type-expr.EBytes" class="anchor"></a><code><span>| </span><span><span class="constructor">EBytes</span> <span class="keyword">of</span> bytes</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bytes literal: <code>0x48, 0x65, 0x6C, 0x6C, 0x6F</code></p><span class="comment-delim">*)</span></div></li><li id="type-expr.EUnit" class="def variant constructor anchored"><a href="#type-expr.EUnit" class="anchor"></a><code><span>| </span><span><span class="constructor">EUnit</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Unit literal: ()</p><span class="comment-delim">*)</span></div></li><li id="type-expr.EVar" class="def variant constructor anchored"><a href="#type-expr.EVar" class="anchor"></a><code><span>| </span><span><span class="constructor">EVar</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Variable reference: variable name lookup</p><span class="comment-delim">*)</span></div></li><li id="type-expr.EArrayAccess" class="def variant constructor anchored"><a href="#type-expr.EArrayAccess" class="anchor"></a><code><span>| </span><span><span class="constructor">EArrayAccess</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Array indexing: arr<code>index</code> First expr is array/slice, second is index expression</p><span class="comment-delim">*)</span></div></li><li id="type-expr.ECall" class="def variant constructor anchored"><a href="#type-expr.ECall" class="anchor"></a><code><span>| </span><span><span class="constructor">ECall</span> <span class="keyword">of</span> string * <span><a href="#type-expr">expr</a> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Function call: function_name(arg1, arg2, ...) String is function name, list contains argument expressions</p><span class="comment-delim">*)</span></div></li><li id="type-expr.EBinOp" class="def variant constructor anchored"><a href="#type-expr.EBinOp" class="anchor"></a><code><span>| </span><span><span class="constructor">EBinOp</span> <span class="keyword">of</span> <a href="#type-binop">binop</a> * <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Binary operation: left_expr OP right_expr Operator precedence handled during parsing</p><span class="comment-delim">*)</span></div></li><li id="type-expr.EUnOp" class="def variant constructor anchored"><a href="#type-expr.EUnOp" class="anchor"></a><code><span>| </span><span><span class="constructor">EUnOp</span> <span class="keyword">of</span> <a href="#type-unop">unop</a> * <a href="#type-expr">expr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Unary operation: OP expr Currently only logical negation (!expr)</p><span class="comment-delim">*)</span></div></li><li id="type-expr.ETuple" class="def variant constructor anchored"><a href="#type-expr.ETuple" class="anchor"></a><code><span>| </span><span><span class="constructor">ETuple</span> <span class="keyword">of</span> <span><a href="#type-expr">expr</a> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Tuple construction: (expr1, expr2, ...) Creates tuple value with heterogeneous elements</p><span class="comment-delim">*)</span></div></li><li id="type-expr.ESome" class="def variant constructor anchored"><a href="#type-expr.ESome" class="anchor"></a><code><span>| </span><span><span class="constructor">ESome</span> <span class="keyword">of</span> <a href="#type-expr">expr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Option Some constructor: Some(value) Wraps value in Some variant of Option type</p><span class="comment-delim">*)</span></div></li><li id="type-expr.ENone" class="def variant constructor anchored"><a href="#type-expr.ENone" class="anchor"></a><code><span>| </span><span><span class="constructor">ENone</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Option None constructor: None Represents absence of value in Option type</p><span class="comment-delim">*)</span></div></li><li id="type-expr.EOk" class="def variant constructor anchored"><a href="#type-expr.EOk" class="anchor"></a><code><span>| </span><span><span class="constructor">EOk</span> <span class="keyword">of</span> <a href="#type-expr">expr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Result Ok constructor: Ok(value) Represents successful result in Result type</p><span class="comment-delim">*)</span></div></li><li id="type-expr.EErr" class="def variant constructor anchored"><a href="#type-expr.EErr" class="anchor"></a><code><span>| </span><span><span class="constructor">EErr</span> <span class="keyword">of</span> <a href="#type-expr">expr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Result Err constructor: Err(error) Represents failed result in Result type</p><span class="comment-delim">*)</span></div></li><li id="type-expr.EIf" class="def variant constructor anchored"><a href="#type-expr.EIf" class="anchor"></a><code><span>| </span><span><span class="constructor">EIf</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Conditional expression: if condition then true_branch else false_branch All three parts are expressions, making this a true expression-oriented construct. The condition must evaluate to a boolean type.</p><span class="comment-delim">*)</span></div></li><li id="type-expr.EMatch" class="def variant constructor anchored"><a href="#type-expr.EMatch" class="anchor"></a><code><span>| </span><span><span class="constructor">EMatch</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <span><a href="#type-match_arm">match_arm</a> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Match expression: match scrutinee with | pattern -&gt; expr Pattern matching allows destructuring of algebraic data types and provides exhaustive case analysis. The scrutinee is evaluated once and matched against each pattern in order until one matches.</p><span class="comment-delim">*)</span></div></li><li id="type-expr.ELet" class="def variant constructor anchored"><a href="#type-expr.ELet" class="anchor"></a><code><span>| </span><span><span class="constructor">ELet</span> <span class="keyword">of</span> string * <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Let expression: let identifier = value_expr in body_expr Local variable binding that introduces a new identifier in the scope of body_expr. The value_expr is evaluated first, then its result is bound to identifier for use within body_expr.</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Expression nodes representing all SNOW computations.</p><p>SNOW is expression-based, meaning all constructs produce values. This type represents the full range of expressions available:</p><ul><li>Literals: Direct values embedded in source code</li><li>Variables: References to bound identifiers</li><li>Operations: Computations combining sub-expressions</li><li>Constructors: Building composite values (tuples, Option, Result)</li><li>Control flow: Conditional expressions and pattern matching</li></ul><p>Design principles:</p><ul><li>Each expression has a deterministic type</li><li>Side effects are explicit (mutable operations, I/O)</li><li>Nested structure allows complex expressions</li></ul></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-pattern"><a href="#type-pattern" class="anchor"></a><code><span><span class="keyword">and</span> pattern</span><span> = </span></code><ol><li id="type-pattern.PWildcard" class="def variant constructor anchored"><a href="#type-pattern.PWildcard" class="anchor"></a><code><span>| </span><span><span class="constructor">PWildcard</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Wildcard pattern (_): matches any value without binding</p><span class="comment-delim">*)</span></div></li><li id="type-pattern.PVar" class="def variant constructor anchored"><a href="#type-pattern.PVar" class="anchor"></a><code><span>| </span><span><span class="constructor">PVar</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Variable pattern: binds matched value to identifier</p><span class="comment-delim">*)</span></div></li><li id="type-pattern.PLiteral" class="def variant constructor anchored"><a href="#type-pattern.PLiteral" class="anchor"></a><code><span>| </span><span><span class="constructor">PLiteral</span> <span class="keyword">of</span> <a href="#type-expr">expr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Literal pattern: matches exact literal values (numbers, strings, booleans)</p><span class="comment-delim">*)</span></div></li><li id="type-pattern.PSome" class="def variant constructor anchored"><a href="#type-pattern.PSome" class="anchor"></a><code><span>| </span><span><span class="constructor">PSome</span> <span class="keyword">of</span> <a href="#type-pattern">pattern</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Some pattern: Some(pattern) for Option type destructuring</p><span class="comment-delim">*)</span></div></li><li id="type-pattern.PNone" class="def variant constructor anchored"><a href="#type-pattern.PNone" class="anchor"></a><code><span>| </span><span><span class="constructor">PNone</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>None pattern: None for Option type</p><span class="comment-delim">*)</span></div></li><li id="type-pattern.POk" class="def variant constructor anchored"><a href="#type-pattern.POk" class="anchor"></a><code><span>| </span><span><span class="constructor">POk</span> <span class="keyword">of</span> <a href="#type-pattern">pattern</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Ok pattern: Ok(pattern) for Result type success case</p><span class="comment-delim">*)</span></div></li><li id="type-pattern.PErr" class="def variant constructor anchored"><a href="#type-pattern.PErr" class="anchor"></a><code><span>| </span><span><span class="constructor">PErr</span> <span class="keyword">of</span> <a href="#type-pattern">pattern</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Err pattern: Err(pattern) for Result type error case</p><span class="comment-delim">*)</span></div></li><li id="type-pattern.PTuple" class="def variant constructor anchored"><a href="#type-pattern.PTuple" class="anchor"></a><code><span>| </span><span><span class="constructor">PTuple</span> <span class="keyword">of</span> <span><a href="#type-pattern">pattern</a> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Tuple pattern: (p1, p2, ...) for tuple destructuring</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Pattern matching constructs for SNOW match expressions.</p><p>Patterns are used in match expressions to destructure values and bind variables. They support both literal matching and structural decomposition of algebraic data types like Option and Result.</p><p>Design principles:</p><ul><li>Exhaustiveness checking: All possible cases must be covered</li><li>Variable binding: Patterns can bind values to identifiers</li><li>Nested patterns: Complex destructuring through pattern composition</li></ul></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-match_arm"><a href="#type-match_arm" class="anchor"></a><code><span><span class="keyword">and</span> match_arm</span><span> = </span><span>{</span></code><ol><li id="type-match_arm.pattern" class="def record field anchored"><a href="#type-match_arm.pattern" class="anchor"></a><code><span>pattern : <a href="#type-pattern">pattern</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Pattern to match against the scrutinee</p><span class="comment-delim">*)</span></div></li><li id="type-match_arm.body" class="def record field anchored"><a href="#type-match_arm.body" class="anchor"></a><code><span>body : <a href="#type-expr">expr</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Expression to evaluate when pattern matches</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Match arm representing a single case in a match expression.</p><p>Contains a pattern to match against and an expression to evaluate when the pattern matches. Match arms are evaluated in order until the first matching pattern is found.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-stmt"><a href="#type-stmt" class="anchor"></a><code><span><span class="keyword">type</span> stmt</span><span> = </span></code><ol><li id="type-stmt.SVarDecl" class="def variant constructor anchored"><a href="#type-stmt.SVarDecl" class="anchor"></a><code><span>| </span><span><span class="constructor">SVarDecl</span> <span class="keyword">of</span> string * <a href="#type-typ">typ</a> * <span><a href="#type-expr">expr</a> option</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Variable declaration: let name: type = expr Optional expr allows for uninitialized variables (filled with default)</p><span class="comment-delim">*)</span></div></li><li id="type-stmt.SAssign" class="def variant constructor anchored"><a href="#type-stmt.SAssign" class="anchor"></a><code><span>| </span><span><span class="constructor">SAssign</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Assignment to mutable variables: lhs := rhs Left side must be a mutable variable or array element</p><span class="comment-delim">*)</span></div></li><li id="type-stmt.SExpr" class="def variant constructor anchored"><a href="#type-stmt.SExpr" class="anchor"></a><code><span>| </span><span><span class="constructor">SExpr</span> <span class="keyword">of</span> <a href="#type-expr">expr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Expression statement: evaluates expression and discards result Used for side effects like function calls</p><span class="comment-delim">*)</span></div></li><li id="type-stmt.SIf" class="def variant constructor anchored"><a href="#type-stmt.SIf" class="anchor"></a><code><span>| </span><span><span class="constructor">SIf</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <span><a href="#type-stmt">stmt</a> list</span> * <span><span><a href="#type-stmt">stmt</a> list</span> option</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>If statement: if condition then statements <code>else statements</code> Being replaced by if expressions in expression contexts</p><span class="comment-delim">*)</span></div></li><li id="type-stmt.SWhile" class="def variant constructor anchored"><a href="#type-stmt.SWhile" class="anchor"></a><code><span>| </span><span><span class="constructor">SWhile</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <span><a href="#type-stmt">stmt</a> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>While loop: while condition do statements Executes statements repeatedly while condition is true</p><span class="comment-delim">*)</span></div></li><li id="type-stmt.SReturn" class="def variant constructor anchored"><a href="#type-stmt.SReturn" class="anchor"></a><code><span>| </span><span><span class="constructor">SReturn</span> <span class="keyword">of</span> <a href="#type-expr">expr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Return statement: return expr Early return from function with value</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Statements in SNOW (currently limited, as SNOW is expression-based).</p><p>Note: SNOW is primarily expression-based, so statements are mainly used for side effects and control flow. Most language constructs are expressions that produce values. Statements are being phased out in favor of expression equivalents (e.g., if expressions instead of if statements).</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-func"><a href="#type-func" class="anchor"></a><code><span><span class="keyword">type</span> func</span><span> = </span><span>{</span></code><ol><li id="type-func.fname" class="def record field anchored"><a href="#type-func.fname" class="anchor"></a><code><span>fname : string;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Function name (follows naming conventions)</p><span class="comment-delim">*)</span></div></li><li id="type-func.params" class="def record field anchored"><a href="#type-func.params" class="anchor"></a><code><span>params : <span><span>(string * <a href="#type-typ">typ</a>)</span> list</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Parameter list: (name, type) pairs</p><span class="comment-delim">*)</span></div></li><li id="type-func.ret" class="def record field anchored"><a href="#type-func.ret" class="anchor"></a><code><span>ret : <a href="#type-typ">typ</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Return type annotation</p><span class="comment-delim">*)</span></div></li><li id="type-func.body" class="def record field anchored"><a href="#type-func.body" class="anchor"></a><code><span>body : <span><a href="#type-stmt">stmt</a> list</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Function body as statement sequence</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Function declaration structure.</p><p>Functions are first-class values in SNOW and can be passed around, stored in variables, and used in higher-order programming.</p><p>Design notes:</p><ul><li>fname follows SNOW naming conventions (CamelCase for public, camelCase for private)</li><li>params support labeled arguments for clarity</li><li>body contains statements but functions should prefer expression-based implementation</li></ul></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-program"><a href="#type-program" class="anchor"></a><code><span><span class="keyword">type</span> program</span><span> = <span><a href="#type-func">func</a> list</span></span></code></div><div class="spec-doc"><p>Complete SNOW program representation.</p><p>Currently simplified as a list of functions. Future versions will include:</p><ul><li>Module declarations and imports</li><li>Type definitions (structs, enums, type aliases)</li><li>Global constants and variables</li><li>Package metadata</li></ul></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-TypeUtils"><a href="#module-TypeUtils" class="anchor"></a><code><span><span class="keyword">module</span> <a href="TypeUtils/index.html">TypeUtils</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Type utility functions for SNOW type system analysis.</p></div></div></div></body></html>
