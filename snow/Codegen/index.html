<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Codegen (snow.Codegen)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../index.html">Index</a> &#x00BB; <a href="../index.html">snow</a> &#x00BB; Codegen</nav><header class="odoc-preamble"><h1>Module <code><span>Codegen</span></code></h1><p>LLVM Code Generator for SNOW Programming Language</p><p>This module implements the final compilation phase, transforming SNOW AST into LLVM IR. It provides comprehensive code generation for SNOW's expression-based functional language features.</p><p>Architecture Overview:</p><ul><li>Expression-oriented code generation matching SNOW's design</li><li>Type-guided LLVM type selection and instruction generation</li><li>SSA form naturally handling SNOW's immutable value semantics</li><li>Stack-based memory management for local values</li></ul><p>Supported Language Features:</p><ul><li>Primitive types (integers, floats, booleans, strings)</li><li>Compound types (arrays, tuples, structs, unions)</li><li>Option/Result algebraic data types</li><li>Function definitions and calls with first-class functions</li><li>Control flow constructs (if/else, while, for loops, match expressions)</li><li>Let bindings with lexical scoping</li><li>Unary and binary operators</li></ul><p>Implementation Status:</p><ul><li>✓ Basic expressions and arithmetic operations</li><li>✓ Function definitions and direct function calls</li><li>✓ Control flow and pattern matching (simplified)</li><li>✓ Array literals and access (simplified)</li><li>✓ Struct type support with field access</li><li>✓ For loop iteration (basic implementation)</li><li>⚠ Advanced features use simplified implementations for stability</li></ul><p>Design Principles:</p><ul><li>Correctness over optimization - generate valid, verifiable LLVM IR</li><li>Incremental complexity - start with basic features, expand systematically</li><li>Type safety - leverage SNOW's type system for code generation</li><li>Testability - comprehensive test coverage for all features</li></ul></header><div class="odoc-content"><div class="odoc-spec"><div class="spec exception anchored" id="exception-Codegen_error"><a href="#exception-Codegen_error" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Codegen_error</span> <span class="keyword">of</span> string</span></code></div><div class="spec-doc"><p>Exception raised when code generation encounters an unrecoverable error</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-codegen_context"><a href="#type-codegen_context" class="anchor"></a><code><span><span class="keyword">type</span> codegen_context</span><span> = </span><span>{</span></code><ol><li id="type-codegen_context.context" class="def record field anchored"><a href="#type-codegen_context.context" class="anchor"></a><code><span>context : <span class="xref-unresolved">Llvm</span>.llcontext;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>LLVM global context for creating types and values</p><span class="comment-delim">*)</span></div></li><li id="type-codegen_context.module_" class="def record field anchored"><a href="#type-codegen_context.module_" class="anchor"></a><code><span>module_ : <span class="xref-unresolved">Llvm</span>.llmodule;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>LLVM module to contain generated functions and globals</p><span class="comment-delim">*)</span></div></li><li id="type-codegen_context.builder" class="def record field anchored"><a href="#type-codegen_context.builder" class="anchor"></a><code><span>builder : <span class="xref-unresolved">Llvm</span>.llbuilder;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>LLVM instruction builder for emitting IR</p><span class="comment-delim">*)</span></div></li><li id="type-codegen_context.named_values" class="def record field anchored"><a href="#type-codegen_context.named_values" class="anchor"></a><code><span>named_values : <span><span>(string, <span class="xref-unresolved">Llvm</span>.llvalue)</span> <span class="xref-unresolved">Stdlib</span>.Hashtbl.t</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Symbol table for local variables</p><span class="comment-delim">*)</span></div></li><li id="type-codegen_context.functions" class="def record field anchored"><a href="#type-codegen_context.functions" class="anchor"></a><code><span>functions : <span><span>(string, <span class="xref-unresolved">Llvm</span>.llvalue)</span> <span class="xref-unresolved">Stdlib</span>.Hashtbl.t</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Symbol table for function values</p><span class="comment-delim">*)</span></div></li><li id="type-codegen_context.function_types" class="def record field anchored"><a href="#type-codegen_context.function_types" class="anchor"></a><code><span>function_types : <span><span>(string, <span class="xref-unresolved">Llvm</span>.lltype)</span> <span class="xref-unresolved">Stdlib</span>.Hashtbl.t</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Function name to type mapping</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Code generation context containing all state needed for LLVM IR generation.</p><p>This structure maintains the LLVM building context and symbol tables for variables and functions during the code generation process.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create_context"><a href="#val-create_context" class="anchor"></a><code><span><span class="keyword">val</span> create_context : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-codegen_context">codegen_context</a></span></code></div><div class="spec-doc"><p>Create a new code generation context for the given module.</p><p>Initializes all LLVM components and symbol tables needed for code generation. The context is the primary state container passed through all codegen functions.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">module_name</span> <p>Name for the LLVM module being generated</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>Fresh codegen context ready for use</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-llvm_type_of_typ"><a href="#val-llvm_type_of_typ" class="anchor"></a><code><span><span class="keyword">val</span> llvm_type_of_typ : <span><a href="#type-codegen_context">codegen_context</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Ast/index.html#type-typ">Ast.typ</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Llvm</span>.lltype</span></code></div><div class="spec-doc"><p>Convert SNOW language types to corresponding LLVM types.</p><p>This function provides the mapping between SNOW's type system and LLVM's type system. It handles all primitive types, compound types, and function types.</p><p>Type Mapping Strategy:</p><ul><li>Integers: Map to corresponding LLVM integer types (i8, i16, i32, i64)</li><li>Floats: Map to LLVM float and double types</li><li>Compound types: Use LLVM struct types for tuples and structs</li><li>Arrays: Simplified to i64 addresses (placeholder implementation)</li><li>Functions: Generate proper LLVM function types</li><li>ADTs: Use tagged unions with simplified representations</li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">ctx</span> <p>Code generation context containing LLVM context</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">typ</span> <p>SNOW type to convert</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>Corresponding LLVM type</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="#exception-Codegen_error"><code>Codegen_error</code></a> <p>if type conversion is not supported</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-codegen_literal"><a href="#val-codegen_literal" class="anchor"></a><code><span><span class="keyword">val</span> codegen_literal : <span><a href="#type-codegen_context">codegen_context</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Ast/index.html#type-expr">Ast.expr</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Llvm</span>.llvalue</span></code></div><div class="spec-doc"><p>Generate LLVM constants for SNOW literal expressions.</p><p>This function handles the conversion of SNOW literal values (integers, floats, booleans, characters, strings, etc.) into their corresponding LLVM constant representations. All generated values are compile-time constants.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">ctx</span> <p>Code generation context</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">literal</span> <p>SNOW literal expression to convert</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>LLVM constant value representing the literal</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="#exception-Codegen_error"><code>Codegen_error</code></a> <p>if the expression is not a literal</p></li></ul></div></div><p>Scope management utilities for variable binding.</p><p>These functions help manage the lexical scoping of variables during code generation, ensuring proper binding and cleanup.</p><div class="odoc-spec"><div class="spec value anchored" id="val-save_variable_binding"><a href="#val-save_variable_binding" class="anchor"></a><code><span><span class="keyword">val</span> save_variable_binding : <span><a href="#type-codegen_context">codegen_context</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Llvm</span>.llvalue option</span></span></code></div><div class="spec-doc"><p>Save the current value of a variable if it exists</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-restore_variable_binding"><a href="#val-restore_variable_binding" class="anchor"></a><code><span><span class="keyword">val</span> restore_variable_binding : 
  <span><a href="#type-codegen_context">codegen_context</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="xref-unresolved">Llvm</span>.llvalue option</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Restore a previously saved variable binding</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-codegen_expr"><a href="#val-codegen_expr" class="anchor"></a><code><span><span class="keyword">val</span> codegen_expr : <span><a href="#type-codegen_context">codegen_context</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Ast/index.html#type-expr">Ast.expr</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Llvm</span>.llvalue</span></code></div><div class="spec-doc"><p>Generate LLVM code for expressions.</p><p>This is the main expression code generation function that dispatches to appropriate handlers based on expression type. It implements SNOW's expression-based semantics where every construct returns a value.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">ctx</span> <p>Code generation context</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">expr</span> <p>SNOW expression to generate code for</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>LLVM value representing the computed expression result</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="#exception-Codegen_error"><code>Codegen_error</code></a> <p>if code generation fails</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-codegen_binop"><a href="#val-codegen_binop" class="anchor"></a><code><span><span class="keyword">val</span> codegen_binop : 
  <span><a href="#type-codegen_context">codegen_context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Ast/index.html#type-binop">Ast.binop</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Llvm</span>.llvalue <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Llvm</span>.llvalue <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Llvm</span>.llvalue</span></code></div><div class="spec-doc"><p>Generate LLVM code for binary operations.</p><p>This function handles all binary operators supported by SNOW, including arithmetic, comparison, and logical operations. It assumes both operands have already been generated and are LLVM values.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">ctx</span> <p>Code generation context</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">op</span> <p>Binary operator to apply</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">lhs</span> <p>Left-hand side LLVM value</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">rhs</span> <p>Right-hand side LLVM value</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>LLVM value representing the operation result</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="#exception-Codegen_error"><code>Codegen_error</code></a> <p>if the operator is not supported</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-codegen_if"><a href="#val-codegen_if" class="anchor"></a><code><span><span class="keyword">val</span> codegen_if : 
  <span><a href="#type-codegen_context">codegen_context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Ast/index.html#type-expr">Ast.expr</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Ast/index.html#type-expr">Ast.expr</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Ast/index.html#type-expr">Ast.expr</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Llvm</span>.llvalue</span></code></div><div class="spec-doc"><p>Generate LLVM code for conditional expressions (if-then-else).</p><p>This function implements SNOW's expression-based conditional construct. It creates basic blocks for each branch and uses a phi node to merge the results, since if expressions return values in SNOW.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">ctx</span> <p>Code generation context</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">condition</span> <p>Boolean condition expression</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">then_expr</span> <p>Expression to evaluate if condition is true</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">else_expr</span> <p>Expression to evaluate if condition is false</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>LLVM value representing the result of the chosen branch</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-generate_llvm_function"><a href="#val-generate_llvm_function" class="anchor"></a><code><span><span class="keyword">val</span> generate_llvm_function : 
  <span><a href="#type-codegen_context">codegen_context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Ast/index.html#type-param">Ast.param</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Ast/index.html#type-typ">Ast.typ</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Ast/index.html#type-expr">Ast.expr</a> <span class="arrow">&#45;&gt;</span></span>
  string * <span class="xref-unresolved">Llvm</span>.llvalue * <span class="xref-unresolved">Llvm</span>.lltype</span></code></div><div class="spec-doc"><p>Generate LLVM function but don't add to context - helper function</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-codegen_function"><a href="#val-codegen_function" class="anchor"></a><code><span><span class="keyword">val</span> codegen_function : 
  <span><a href="#type-codegen_context">codegen_context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Ast/index.html#type-param">Ast.param</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Ast/index.html#type-typ">Ast.typ</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Ast/index.html#type-expr">Ast.expr</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Llvm</span>.llvalue</span></code></div><div class="spec-doc"><p>Generate LLVM code for a function definition</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-codegen_call"><a href="#val-codegen_call" class="anchor"></a><code><span><span class="keyword">val</span> codegen_call : <span><a href="#type-codegen_context">codegen_context</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Ast/index.html#type-expr">Ast.expr</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Ast/index.html#type-expr">Ast.expr</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Llvm</span>.llvalue</span></code></div><div class="spec-doc"><p>Generate LLVM code for function call</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-codegen_match"><a href="#val-codegen_match" class="anchor"></a><code><span><span class="keyword">val</span> codegen_match : 
  <span><a href="#type-codegen_context">codegen_context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Ast/index.html#type-expr">Ast.expr</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Ast/index.html#type-match_arm">Ast.match_arm</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Llvm</span>.llvalue</span></code></div><div class="spec-doc"><p>Generate LLVM code for match expressions - simplified safe implementation</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-codegen_pattern_match"><a href="#val-codegen_pattern_match" class="anchor"></a><code><span><span class="keyword">val</span> codegen_pattern_match : 
  <span><a href="#type-codegen_context">codegen_context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Llvm</span>.llvalue <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Ast/index.html#type-pattern">Ast.pattern</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Llvm</span>.llvalue</span></code></div><div class="spec-doc"><p>Generate LLVM code for pattern matching - simplified safe implementation</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-codegen_while"><a href="#val-codegen_while" class="anchor"></a><code><span><span class="keyword">val</span> codegen_while : <span><a href="#type-codegen_context">codegen_context</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Ast/index.html#type-expr">Ast.expr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Ast/index.html#type-expr">Ast.expr</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Llvm</span>.llvalue</span></code></div><div class="spec-doc"><p>Generate LLVM code for while loops</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-codegen_for"><a href="#val-codegen_for" class="anchor"></a><code><span><span class="keyword">val</span> codegen_for : 
  <span><a href="#type-codegen_context">codegen_context</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Ast/index.html#type-expr">Ast.expr</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Ast/index.html#type-expr">Ast.expr</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Llvm</span>.llvalue</span></code></div><div class="spec-doc"><p>Generate LLVM code for for loops</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-codegen_block"><a href="#val-codegen_block" class="anchor"></a><code><span><span class="keyword">val</span> codegen_block : <span><a href="#type-codegen_context">codegen_context</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Ast/index.html#type-expr">Ast.expr</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Llvm</span>.llvalue</span></code></div><div class="spec-doc"><p>Generate LLVM code for block expressions</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-codegen_unop"><a href="#val-codegen_unop" class="anchor"></a><code><span><span class="keyword">val</span> codegen_unop : <span><a href="#type-codegen_context">codegen_context</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Ast/index.html#type-unop">Ast.unop</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Ast/index.html#type-expr">Ast.expr</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Llvm</span>.llvalue</span></code></div><div class="spec-doc"><p>Generate LLVM code for unary operations.</p><p>Handles negation and logical not operations, ensuring proper type conversion for boolean results to maintain consistency with the main function return type.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">ctx</span> <p>Code generation context</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">op</span> <p>Unary operator (Not or Neg)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">expr</span> <p>Expression to apply the operator to</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>LLVM value representing the operation result</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-codegen_array_access"><a href="#val-codegen_array_access" class="anchor"></a><code><span><span class="keyword">val</span> codegen_array_access : 
  <span><a href="#type-codegen_context">codegen_context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Ast/index.html#type-expr">Ast.expr</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Ast/index.html#type-expr">Ast.expr</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Llvm</span>.llvalue</span></code></div><div class="spec-doc"><p>Generate LLVM code for array access - simplified implementation</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-codegen_field_access"><a href="#val-codegen_field_access" class="anchor"></a><code><span><span class="keyword">val</span> codegen_field_access : 
  <span><a href="#type-codegen_context">codegen_context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Ast/index.html#type-expr">Ast.expr</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Llvm</span>.llvalue</span></code></div><div class="spec-doc"><p>Generate LLVM code for field access</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-codegen_struct"><a href="#val-codegen_struct" class="anchor"></a><code><span><span class="keyword">val</span> codegen_struct : 
  <span><a href="#type-codegen_context">codegen_context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Ast/index.html#type-struct_field_init">Ast.struct_field_init</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Llvm</span>.llvalue</span></code></div><div class="spec-doc"><p>Generate LLVM code for struct construction.</p><p>Creates proper LLVM struct values from field initializers. This maintains the structural integrity needed for field access operations.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">ctx</span> <p>Code generation context</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">field_inits</span> <p>List of field initializers</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>LLVM struct value representing the constructed struct</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-codegen_tuple"><a href="#val-codegen_tuple" class="anchor"></a><code><span><span class="keyword">val</span> codegen_tuple : <span><a href="#type-codegen_context">codegen_context</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Ast/index.html#type-expr">Ast.expr</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Llvm</span>.llvalue</span></code></div><div class="spec-doc"><p>Generate LLVM code for tuple construction.</p><p>Creates proper LLVM struct values for tuples. This maintains the integrity of the tuple structure for use in other operations.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">ctx</span> <p>Code generation context</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">exprs</span> <p>List of expressions that form the tuple elements</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>LLVM struct value representing the tuple</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-codegen_array"><a href="#val-codegen_array" class="anchor"></a><code><span><span class="keyword">val</span> codegen_array : <span><a href="#type-codegen_context">codegen_context</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Ast/index.html#type-expr">Ast.expr</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Llvm</span>.llvalue</span></code></div><div class="spec-doc"><p>Generate LLVM code for array literals - simplified implementation</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-codegen_some"><a href="#val-codegen_some" class="anchor"></a><code><span><span class="keyword">val</span> codegen_some : <span><a href="#type-codegen_context">codegen_context</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Ast/index.html#type-expr">Ast.expr</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Llvm</span>.llvalue</span></code></div><div class="spec-doc"><p>Generate LLVM code for Option Some</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-codegen_none"><a href="#val-codegen_none" class="anchor"></a><code><span><span class="keyword">val</span> codegen_none : <span><a href="#type-codegen_context">codegen_context</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Llvm</span>.llvalue</span></code></div><div class="spec-doc"><p>Generate LLVM code for Option None</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-codegen_ok"><a href="#val-codegen_ok" class="anchor"></a><code><span><span class="keyword">val</span> codegen_ok : <span><a href="#type-codegen_context">codegen_context</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Ast/index.html#type-expr">Ast.expr</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Llvm</span>.llvalue</span></code></div><div class="spec-doc"><p>Generate LLVM code for Result Ok</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-codegen_err"><a href="#val-codegen_err" class="anchor"></a><code><span><span class="keyword">val</span> codegen_err : <span><a href="#type-codegen_context">codegen_context</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Ast/index.html#type-expr">Ast.expr</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Llvm</span>.llvalue</span></code></div><div class="spec-doc"><p>Generate LLVM code for Result Err</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-codegen_program"><a href="#val-codegen_program" class="anchor"></a><code><span><span class="keyword">val</span> codegen_program : <span><a href="../Ast/index.html#type-expr">Ast.expr</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Llvm</span>.llmodule</span></code></div><div class="spec-doc"><p>Generate LLVM code for a complete program</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-generate_llvm_ir"><a href="#val-generate_llvm_ir" class="anchor"></a><code><span><span class="keyword">val</span> generate_llvm_ir : <span><a href="../Ast/index.html#type-expr">Ast.expr</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Generate LLVM IR string for an expression</p></div></div></div></body></html>
