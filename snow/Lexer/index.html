<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lexer (snow.Lexer)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">Index</a> &#x00BB; <a href="../index.html">snow</a> &#x00BB; Lexer</nav><header class="odoc-preamble"><h1>Module <code><span>Lexer</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec exception anchored" id="exception-Lex_error"><a href="#exception-Lex_error" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Lex_error</span> <span class="keyword">of</span> string</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-token"><a href="#type-token" class="anchor"></a><code><span><span class="keyword">type</span> token</span><span> = </span></code><ol><li id="type-token.I8" class="def variant constructor anchored"><a href="#type-token.I8" class="anchor"></a><code><span>| </span><span><span class="constructor">I8</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>8-bit signed integer: 42i8</p><span class="comment-delim">*)</span></div></li><li id="type-token.U8" class="def variant constructor anchored"><a href="#type-token.U8" class="anchor"></a><code><span>| </span><span><span class="constructor">U8</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>8-bit unsigned integer: 255u8</p><span class="comment-delim">*)</span></div></li><li id="type-token.I16" class="def variant constructor anchored"><a href="#type-token.I16" class="anchor"></a><code><span>| </span><span><span class="constructor">I16</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>16-bit signed integer: 1000i16</p><span class="comment-delim">*)</span></div></li><li id="type-token.U16" class="def variant constructor anchored"><a href="#type-token.U16" class="anchor"></a><code><span>| </span><span><span class="constructor">U16</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>16-bit unsigned integer: 65535u16</p><span class="comment-delim">*)</span></div></li><li id="type-token.I32" class="def variant constructor anchored"><a href="#type-token.I32" class="anchor"></a><code><span>| </span><span><span class="constructor">I32</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>32-bit signed integer: 42i32</p><span class="comment-delim">*)</span></div></li><li id="type-token.U32" class="def variant constructor anchored"><a href="#type-token.U32" class="anchor"></a><code><span>| </span><span><span class="constructor">U32</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>32-bit unsigned integer: 42u32</p><span class="comment-delim">*)</span></div></li><li id="type-token.I64" class="def variant constructor anchored"><a href="#type-token.I64" class="anchor"></a><code><span>| </span><span><span class="constructor">I64</span> <span class="keyword">of</span> int64</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>64-bit signed integer: 42i64</p><span class="comment-delim">*)</span></div></li><li id="type-token.U64" class="def variant constructor anchored"><a href="#type-token.U64" class="anchor"></a><code><span>| </span><span><span class="constructor">U64</span> <span class="keyword">of</span> int64</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>64-bit unsigned integer: 42u64</p><span class="comment-delim">*)</span></div></li><li id="type-token.INT" class="def variant constructor anchored"><a href="#type-token.INT" class="anchor"></a><code><span>| </span><span><span class="constructor">INT</span> <span class="keyword">of</span> int64</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Default integer literal: 42 (inferred as i64)</p><span class="comment-delim">*)</span></div></li><li id="type-token.UINT" class="def variant constructor anchored"><a href="#type-token.UINT" class="anchor"></a><code><span>| </span><span><span class="constructor">UINT</span> <span class="keyword">of</span> int64</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Explicit unsigned integer: 42uint</p><span class="comment-delim">*)</span></div></li><li id="type-token.F32" class="def variant constructor anchored"><a href="#type-token.F32" class="anchor"></a><code><span>| </span><span><span class="constructor">F32</span> <span class="keyword">of</span> float</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>32-bit IEEE 754 float: 3.14f32</p><span class="comment-delim">*)</span></div></li><li id="type-token.F64" class="def variant constructor anchored"><a href="#type-token.F64" class="anchor"></a><code><span>| </span><span><span class="constructor">F64</span> <span class="keyword">of</span> float</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>64-bit IEEE 754 float: 3.14f64</p><span class="comment-delim">*)</span></div></li><li id="type-token.FLOAT" class="def variant constructor anchored"><a href="#type-token.FLOAT" class="anchor"></a><code><span>| </span><span><span class="constructor">FLOAT</span> <span class="keyword">of</span> float</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Default float literal: 3.14 (inferred as f64)</p><span class="comment-delim">*)</span></div></li><li id="type-token.BOOL" class="def variant constructor anchored"><a href="#type-token.BOOL" class="anchor"></a><code><span>| </span><span><span class="constructor">BOOL</span> <span class="keyword">of</span> bool</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Boolean literal: true or false</p><span class="comment-delim">*)</span></div></li><li id="type-token.CHAR" class="def variant constructor anchored"><a href="#type-token.CHAR" class="anchor"></a><code><span>| </span><span><span class="constructor">CHAR</span> <span class="keyword">of</span> char</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Unicode character: 'A', '\n', '\u</p><p>F600</p><p>'</p><span class="comment-delim">*)</span></div></li><li id="type-token.STRING" class="def variant constructor anchored"><a href="#type-token.STRING" class="anchor"></a><code><span>| </span><span><span class="constructor">STRING</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>UTF-8 string: &quot;hello&quot;, &quot;world\n&quot;</p><span class="comment-delim">*)</span></div></li><li id="type-token.BYTES" class="def variant constructor anchored"><a href="#type-token.BYTES" class="anchor"></a><code><span>| </span><span><span class="constructor">BYTES</span> <span class="keyword">of</span> bytes</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Raw byte array: <code>0x48, 0x65, 0x6C, 0x6C, 0x6F</code></p><span class="comment-delim">*)</span></div></li><li id="type-token.UNIT" class="def variant constructor anchored"><a href="#type-token.UNIT" class="anchor"></a><code><span>| </span><span><span class="constructor">UNIT</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Unit value: ()</p><span class="comment-delim">*)</span></div></li><li id="type-token.IDENT" class="def variant constructor anchored"><a href="#type-token.IDENT" class="anchor"></a><code><span>| </span><span><span class="constructor">IDENT</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>User identifier: variable, function names</p><span class="comment-delim">*)</span></div></li><li id="type-token.KW_I8" class="def variant constructor anchored"><a href="#type-token.KW_I8" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_I8</span></span></code></li><li id="type-token.KW_U8" class="def variant constructor anchored"><a href="#type-token.KW_U8" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_U8</span></span></code></li><li id="type-token.KW_I16" class="def variant constructor anchored"><a href="#type-token.KW_I16" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_I16</span></span></code></li><li id="type-token.KW_U16" class="def variant constructor anchored"><a href="#type-token.KW_U16" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_U16</span></span></code></li><li id="type-token.KW_I32" class="def variant constructor anchored"><a href="#type-token.KW_I32" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_I32</span></span></code></li><li id="type-token.KW_U32" class="def variant constructor anchored"><a href="#type-token.KW_U32" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_U32</span></span></code></li><li id="type-token.KW_I64" class="def variant constructor anchored"><a href="#type-token.KW_I64" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_I64</span></span></code></li><li id="type-token.KW_U64" class="def variant constructor anchored"><a href="#type-token.KW_U64" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_U64</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Fixed-width integer type keywords</p><span class="comment-delim">*)</span></div></li><li id="type-token.KW_INT" class="def variant constructor anchored"><a href="#type-token.KW_INT" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_INT</span></span></code></li><li id="type-token.KW_UINT" class="def variant constructor anchored"><a href="#type-token.KW_UINT" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_UINT</span></span></code></li><li id="type-token.KW_F32" class="def variant constructor anchored"><a href="#type-token.KW_F32" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_F32</span></span></code></li><li id="type-token.KW_F64" class="def variant constructor anchored"><a href="#type-token.KW_F64" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_F64</span></span></code></li><li id="type-token.KW_FLOAT" class="def variant constructor anchored"><a href="#type-token.KW_FLOAT" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_FLOAT</span></span></code></li><li id="type-token.KW_BOOL" class="def variant constructor anchored"><a href="#type-token.KW_BOOL" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_BOOL</span></span></code></li><li id="type-token.KW_CHAR" class="def variant constructor anchored"><a href="#type-token.KW_CHAR" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_CHAR</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Default and floating-point type keywords</p><span class="comment-delim">*)</span></div></li><li id="type-token.KW_STRING" class="def variant constructor anchored"><a href="#type-token.KW_STRING" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_STRING</span></span></code></li><li id="type-token.KW_BYTES" class="def variant constructor anchored"><a href="#type-token.KW_BYTES" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_BYTES</span></span></code></li><li id="type-token.KW_UNIT" class="def variant constructor anchored"><a href="#type-token.KW_UNIT" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_UNIT</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>String, binary data, and unit type keywords</p><span class="comment-delim">*)</span></div></li><li id="type-token.KW_IF" class="def variant constructor anchored"><a href="#type-token.KW_IF" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_IF</span></span></code></li><li id="type-token.KW_THEN" class="def variant constructor anchored"><a href="#type-token.KW_THEN" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_THEN</span></span></code></li><li id="type-token.KW_ELSE" class="def variant constructor anchored"><a href="#type-token.KW_ELSE" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_ELSE</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Conditional expressions: if cond then expr else expr</p><span class="comment-delim">*)</span></div></li><li id="type-token.KW_MATCH" class="def variant constructor anchored"><a href="#type-token.KW_MATCH" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_MATCH</span></span></code></li><li id="type-token.KW_WITH" class="def variant constructor anchored"><a href="#type-token.KW_WITH" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_WITH</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Pattern matching: match expr with | pattern -&gt; expr</p><span class="comment-delim">*)</span></div></li><li id="type-token.KW_LET" class="def variant constructor anchored"><a href="#type-token.KW_LET" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_LET</span></span></code></li><li id="type-token.KW_FUN" class="def variant constructor anchored"><a href="#type-token.KW_FUN" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_FUN</span></span></code></li><li id="type-token.KW_IN" class="def variant constructor anchored"><a href="#type-token.KW_IN" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_IN</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Function definition and let bindings</p><span class="comment-delim">*)</span></div></li><li id="type-token.KW_TYPE" class="def variant constructor anchored"><a href="#type-token.KW_TYPE" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_TYPE</span></span></code></li><li id="type-token.KW_STRUCT" class="def variant constructor anchored"><a href="#type-token.KW_STRUCT" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_STRUCT</span></span></code></li><li id="type-token.KW_UNION" class="def variant constructor anchored"><a href="#type-token.KW_UNION" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_UNION</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>User-defined types: algebraic data types and structures</p><span class="comment-delim">*)</span></div></li><li id="type-token.KW_PACKAGE" class="def variant constructor anchored"><a href="#type-token.KW_PACKAGE" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_PACKAGE</span></span></code></li><li id="type-token.KW_IMPORT" class="def variant constructor anchored"><a href="#type-token.KW_IMPORT" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_IMPORT</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Package declarations and imports</p><span class="comment-delim">*)</span></div></li><li id="type-token.KW_SOME" class="def variant constructor anchored"><a href="#type-token.KW_SOME" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_SOME</span></span></code></li><li id="type-token.KW_NONE" class="def variant constructor anchored"><a href="#type-token.KW_NONE" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_NONE</span></span></code></li><li id="type-token.KW_OK" class="def variant constructor anchored"><a href="#type-token.KW_OK" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_OK</span></span></code></li><li id="type-token.KW_ERR" class="def variant constructor anchored"><a href="#type-token.KW_ERR" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_ERR</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Built-in variant constructors for Option and Result types</p><span class="comment-delim">*)</span></div></li><li id="type-token.KW_MUTABLE" class="def variant constructor anchored"><a href="#type-token.KW_MUTABLE" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_MUTABLE</span></span></code></li><li id="type-token.KW_TRUE" class="def variant constructor anchored"><a href="#type-token.KW_TRUE" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_TRUE</span></span></code></li><li id="type-token.KW_FALSE" class="def variant constructor anchored"><a href="#type-token.KW_FALSE" class="anchor"></a><code><span>| </span><span><span class="constructor">KW_FALSE</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Mutability modifier and boolean literals</p><span class="comment-delim">*)</span></div></li><li id="type-token.PLUS" class="def variant constructor anchored"><a href="#type-token.PLUS" class="anchor"></a><code><span>| </span><span><span class="constructor">PLUS</span></span></code></li><li id="type-token.MINUS" class="def variant constructor anchored"><a href="#type-token.MINUS" class="anchor"></a><code><span>| </span><span><span class="constructor">MINUS</span></span></code></li><li id="type-token.MULT" class="def variant constructor anchored"><a href="#type-token.MULT" class="anchor"></a><code><span>| </span><span><span class="constructor">MULT</span></span></code></li><li id="type-token.DIV" class="def variant constructor anchored"><a href="#type-token.DIV" class="anchor"></a><code><span>| </span><span><span class="constructor">DIV</span></span></code></li><li id="type-token.MOD" class="def variant constructor anchored"><a href="#type-token.MOD" class="anchor"></a><code><span>| </span><span><span class="constructor">MOD</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Arithmetic operators: +, -, *, /, %</p><span class="comment-delim">*)</span></div></li><li id="type-token.EQ" class="def variant constructor anchored"><a href="#type-token.EQ" class="anchor"></a><code><span>| </span><span><span class="constructor">EQ</span></span></code></li><li id="type-token.NEQ" class="def variant constructor anchored"><a href="#type-token.NEQ" class="anchor"></a><code><span>| </span><span><span class="constructor">NEQ</span></span></code></li><li id="type-token.LT" class="def variant constructor anchored"><a href="#type-token.LT" class="anchor"></a><code><span>| </span><span><span class="constructor">LT</span></span></code></li><li id="type-token.LE" class="def variant constructor anchored"><a href="#type-token.LE" class="anchor"></a><code><span>| </span><span><span class="constructor">LE</span></span></code></li><li id="type-token.GT" class="def variant constructor anchored"><a href="#type-token.GT" class="anchor"></a><code><span>| </span><span><span class="constructor">GT</span></span></code></li><li id="type-token.GE" class="def variant constructor anchored"><a href="#type-token.GE" class="anchor"></a><code><span>| </span><span><span class="constructor">GE</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Comparison operators: ==, !=, &lt;, &lt;=, &gt;, &gt;=</p><span class="comment-delim">*)</span></div></li><li id="type-token.AND" class="def variant constructor anchored"><a href="#type-token.AND" class="anchor"></a><code><span>| </span><span><span class="constructor">AND</span></span></code></li><li id="type-token.OR" class="def variant constructor anchored"><a href="#type-token.OR" class="anchor"></a><code><span>| </span><span><span class="constructor">OR</span></span></code></li><li id="type-token.NOT" class="def variant constructor anchored"><a href="#type-token.NOT" class="anchor"></a><code><span>| </span><span><span class="constructor">NOT</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Logical operators: &amp;&amp;, ||, ! (short-circuiting)</p><span class="comment-delim">*)</span></div></li><li id="type-token.ASSIGN" class="def variant constructor anchored"><a href="#type-token.ASSIGN" class="anchor"></a><code><span>| </span><span><span class="constructor">ASSIGN</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Assignment operator: := (for mutable variables)</p><span class="comment-delim">*)</span></div></li><li id="type-token.PIPE" class="def variant constructor anchored"><a href="#type-token.PIPE" class="anchor"></a><code><span>| </span><span><span class="constructor">PIPE</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Pipe operator: |&gt; (function composition, left-to-right)</p><span class="comment-delim">*)</span></div></li><li id="type-token.ARROW" class="def variant constructor anchored"><a href="#type-token.ARROW" class="anchor"></a><code><span>| </span><span><span class="constructor">ARROW</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Arrow operator: -&gt; (function types, case arms)</p><span class="comment-delim">*)</span></div></li><li id="type-token.DOUBLE_COLON" class="def variant constructor anchored"><a href="#type-token.DOUBLE_COLON" class="anchor"></a><code><span>| </span><span><span class="constructor">DOUBLE_COLON</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Double colon: :: (type ascription, module access)</p><span class="comment-delim">*)</span></div></li><li id="type-token.LPAREN" class="def variant constructor anchored"><a href="#type-token.LPAREN" class="anchor"></a><code><span>| </span><span><span class="constructor">LPAREN</span></span></code></li><li id="type-token.RPAREN" class="def variant constructor anchored"><a href="#type-token.RPAREN" class="anchor"></a><code><span>| </span><span><span class="constructor">RPAREN</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Parentheses: (, ) (grouping, tuples, function calls)</p><span class="comment-delim">*)</span></div></li><li id="type-token.LBRACE" class="def variant constructor anchored"><a href="#type-token.LBRACE" class="anchor"></a><code><span>| </span><span><span class="constructor">LBRACE</span></span></code></li><li id="type-token.RBRACE" class="def variant constructor anchored"><a href="#type-token.RBRACE" class="anchor"></a><code><span>| </span><span><span class="constructor">RBRACE</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Braces: <code>, </code> (struct literals, blocks)</p><span class="comment-delim">*)</span></div></li><li id="type-token.LBRACKET" class="def variant constructor anchored"><a href="#type-token.LBRACKET" class="anchor"></a><code><span>| </span><span><span class="constructor">LBRACKET</span></span></code></li><li id="type-token.RBRACKET" class="def variant constructor anchored"><a href="#type-token.RBRACKET" class="anchor"></a><code><span>| </span><span><span class="constructor">RBRACKET</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Brackets: <code>, </code> (arrays, slices, indexing)</p><span class="comment-delim">*)</span></div></li><li id="type-token.COMMA" class="def variant constructor anchored"><a href="#type-token.COMMA" class="anchor"></a><code><span>| </span><span><span class="constructor">COMMA</span></span></code></li><li id="type-token.SEMICOLON" class="def variant constructor anchored"><a href="#type-token.SEMICOLON" class="anchor"></a><code><span>| </span><span><span class="constructor">SEMICOLON</span></span></code></li><li id="type-token.COLON" class="def variant constructor anchored"><a href="#type-token.COLON" class="anchor"></a><code><span>| </span><span><span class="constructor">COLON</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Punctuation: , (separators), ; (terminators), : (type annotations)</p><span class="comment-delim">*)</span></div></li><li id="type-token.DOT" class="def variant constructor anchored"><a href="#type-token.DOT" class="anchor"></a><code><span>| </span><span><span class="constructor">DOT</span></span></code></li><li id="type-token.EQUAL" class="def variant constructor anchored"><a href="#type-token.EQUAL" class="anchor"></a><code><span>| </span><span><span class="constructor">EQUAL</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Access and binding: . (field access), = (let bindings)</p><span class="comment-delim">*)</span></div></li><li id="type-token.PIPE_SYMBOL" class="def variant constructor anchored"><a href="#type-token.PIPE_SYMBOL" class="anchor"></a><code><span>| </span><span><span class="constructor">PIPE_SYMBOL</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Pipe symbol: | (pattern matching, algebraic data types)</p><span class="comment-delim">*)</span></div></li><li id="type-token.UNDERSCORE" class="def variant constructor anchored"><a href="#type-token.UNDERSCORE" class="anchor"></a><code><span>| </span><span><span class="constructor">UNDERSCORE</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Underscore: _ (wildcard patterns, discarded values)</p><span class="comment-delim">*)</span></div></li><li id="type-token.EOF" class="def variant constructor anchored"><a href="#type-token.EOF" class="anchor"></a><code><span>| </span><span><span class="constructor">EOF</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>End of file marker (signals completion of input stream)</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Token type representing all lexical elements in SNOW source code.</p><p>This type defines every possible token that can appear in a SNOW program. Tokens are the atomic units produced by lexical analysis and consumed by the parser to build the AST.</p><p>Organization:</p><ul><li>Literals: Direct values (numbers, strings, characters)</li><li>Keywords: Reserved words with special meaning</li><li>Operators: Symbols for computations and comparisons</li><li>Delimiters: Punctuation for structure (parentheses, brackets)</li><li>Special: EOF and other meta-tokens</li></ul><p>Design notes:</p><ul><li>Literal tokens carry their values for immediate use</li><li>Keyword tokens distinguished from identifiers for parsing</li><li>Operator precedence handled during parsing, not tokenization</li><li>Position information tracked separately by parser</li></ul></div></div><p>Character classification functions for lexical analysis.</p><div class="odoc-spec"><div class="spec value anchored" id="val-is_digit"><a href="#val-is_digit" class="anchor"></a><code><span><span class="keyword">val</span> is_digit : <span>char <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Check if character is a decimal digit (0-9). Used for parsing integer and floating-point literals.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_alpha"><a href="#val-is_alpha" class="anchor"></a><code><span><span class="keyword">val</span> is_alpha : <span>char <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Check if character can start an identifier (letter or underscore). SNOW identifiers follow Unicode identifier standards.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_alnum"><a href="#val-is_alnum" class="anchor"></a><code><span><span class="keyword">val</span> is_alnum : <span>char <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Check if character can continue an identifier (alphanumeric or underscore). Used after the first character of an identifier.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_hex_digit"><a href="#val-is_hex_digit" class="anchor"></a><code><span><span class="keyword">val</span> is_hex_digit : <span>char <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Check if character is a hexadecimal digit (0-9, a-f, A-F). Used for parsing hexadecimal integer literals and Unicode escapes.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_bin_digit"><a href="#val-is_bin_digit" class="anchor"></a><code><span><span class="keyword">val</span> is_bin_digit : <span>char <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Check if character is a binary digit (0 or 1). Used for parsing binary integer literals (0b prefix).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_oct_digit"><a href="#val-is_oct_digit" class="anchor"></a><code><span><span class="keyword">val</span> is_oct_digit : <span>char <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Check if character is an octal digit (0-7). Used for parsing octal integer literals (0o prefix).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-keywords"><a href="#val-keywords" class="anchor"></a><code><span><span class="keyword">val</span> keywords : <span><span>(string * <a href="#type-token">token</a>)</span> list</span></span></code></div><div class="spec-doc"><p>List of reserved keywords in SNOW language.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-skip"><a href="#val-skip" class="anchor"></a><code><span><span class="keyword">val</span> skip : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Skip whitespace and comments, returning the next significant character position.</p><p>Handles both single-line comments (//) and multi-line comments (/* ... */). Recursively processes nested comments and whitespace until a meaningful character is found or end of input is reached.</p><p>Parameters:</p><ul><li>input: Source code string to process</li><li>len: Length of input string (for bounds checking)</li><li>i: Current position in input string</li></ul><p>Returns: Position of next non-whitespace, non-comment character</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-parse_char"><a href="#val-parse_char" class="anchor"></a><code><span><span class="keyword">val</span> parse_char : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> char * int</span></code></div><div class="spec-doc"><p>Parse a character literal with escape sequence support.</p><p>Handles both regular characters ('A') and escape sequences ('\n', '\t', etc.). Supports standard C-style escape sequences including null terminator.</p><p>Parameters:</p><ul><li>input: Source code string</li><li>i: Starting position (should point to opening quote)</li><li>len: Input string length</li></ul><p>Returns: (parsed_character, next_position) tuple Raises: Lex_error for invalid escape sequences or unterminated literals</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-parse_string"><a href="#val-parse_string" class="anchor"></a><code><span><span class="keyword">val</span> parse_string : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> string * int</span></code></div><div class="spec-doc"><p>Parse a string literal with escape sequence support.</p><p>Processes UTF-8 string literals enclosed in double quotes. Supports standard escape sequences and accumulates characters into a buffer for efficient string construction.</p><p>Parameters:</p><ul><li>input: Source code string</li><li>i: Starting position (should point to opening quote)</li><li>len: Input string length</li></ul><p>Returns: (parsed_string, next_position) tuple Raises: Lex_error for invalid escape sequences or unterminated strings</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-parse_number"><a href="#val-parse_number" class="anchor"></a><code><span><span class="keyword">val</span> parse_number : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-token">token</a> * int</span></code></div><div class="spec-doc"><p>Parse numeric literals with optional type suffixes.</p><p>Handles both integer and floating-point literals with explicit type annotations. Supports type suffixes like i32, u64, f32, f64, uint, etc. Automatically determines whether the literal is integer or float based on decimal point presence.</p><p>Examples:</p><ul><li>42 -&gt; INT(42)</li><li>42i32 -&gt; I32(42)</li><li>3.14 -&gt; FLOAT(3.14)</li><li>2.5f32 -&gt; F32(2.5)</li></ul><p>Parameters:</p><ul><li>input: Source code string</li><li>i: Starting position of the number</li><li>len: Input string length</li></ul><p>Returns: (token, next_position) tuple where token contains parsed value Raises: Lex_error for invalid suffixes or malformed numbers</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lex"><a href="#val-lex" class="anchor"></a><code><span><span class="keyword">val</span> lex : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-token">token</a> list</span></span></code></div><div class="spec-doc"><p>Main lexical analysis function - converts source code to token stream.</p><p>Performs complete tokenization of SNOW source code in a single pass. Uses recursive descent approach with specialized parsers for different token types. Handles operator precedence, comment skipping, and error recovery.</p><p>Process: 1. Skip whitespace and comments 2. Identify token type by first character(s) 3. Dispatch to appropriate specialized parser 4. Accumulate tokens in reverse order for efficiency 5. Return complete token list with EOF marker</p><p>Parameters:</p><ul><li>input: Complete source code string to tokenize</li></ul><p>Returns: List of tokens in source order, terminated with EOF Raises: Lex_error for invalid characters or malformed tokens</p></div></div></div></body></html>
